#! /usr/local/bin/clisp
(setf *encoding* :utf-8)
(setf *random-state* (make-random-state t))
(setf *max-int* 128)

(defun byte-divisible (n)
  (if (zerop (mod size 8)) t nil))

(defmacro modo (o a b c)
  `(mod (funcall (symbol-function ',o) (mod ,a ,c) (mod ,b ,c)) ,c))

(defun encoding-keyword-to-native (encoding)
  (intern (string encoding) (find-package :charset)))
(defun %string-to-octets (string encoding)
  (ext:convert-string-to-bytes string (encoding-keyword-to-native encoding)))
(defun %octets-to-string (octets encoding)
  (ext:convert-string-from-bytes octets (encoding-keyword-to-native encoding)))

(defun rand (size)
  (let ((lst ()))
    (dotimes (i size)
       (setf lst (cons (random *max-int*) lst)))
   lst))

; TODO prints extra byte?
(defun gen (size-string)
  (when (null size-string)
    (setf size-string "4096"))
  (setf size (parse-integer size-string :junk-allowed t))
  (unless (numberp size)
    (error "size must be a number"))
  (unless (byte-divisible size)
    (error "size must dbe divisible by 8"))
  (defvar buffer (rand size))
  (princ (%octets-to-string (coerce buffer 'vector) *encoding*)))

(defun enc (input-path pad-path offset-string)
  (when (null input-path)
    (error "must supply input path"))
  (when (null pad-path)
    (error "must supply pad path"))
  (when (null offset-string)
    (setq offset-string "0"))
  (setq offset (parse-integer offset-string :junk-allowed t))
  (unless (numberp offset)
    (error "offset must be a number"))
  (with-open-file (input input-path)
    (with-open-file (pad pad-path)
      (setq input-buffer (%string-to-octets (read-line input) *encoding*))
      (setq pad-buffer (%string-to-octets (read-line pad) *encoding*))
      (setq output-buffer '())
      (when (> (+ offset (length input-buffer)) (length pad-buffer))
        (error "offset is too large for pad"))
      (dotimes (i (length input-buffer))
        (setf x (elt input-buffer i))
        (setf y (elt pad-buffer (+ i offset)))
        (setf cur (modo + x y *max-int*))
        (setf output-buffer (append output-buffer (list cur))))
      (princ (%octets-to-string (coerce output-buffer 'vector) *encoding*)))))

(defun dec (input-path pad-path offset-string)
  (when (null input-path)
    (error "must supply input path"))
  (when (null pad-path)
    (error "must supply pad path"))
  (when (null offset-string)
    (setq offset-string "0"))
  (setq offset (parse-integer offset-string :junk-allowed t))
  (unless (numberp offset)
    (error "offset must be a number"))
  (with-open-file (input input-path)
    (with-open-file (pad pad-path)
      (setq input-buffer (%string-to-octets (read-line input) *encoding*))
      (setq pad-buffer (%string-to-octets (read-line pad) *encoding*))
      (setq output-buffer '())
      (when (> (+ offset (length input-buffer)) (length pad-buffer))
        (error "offset is too large for pad"))
      (dotimes (i (length input-buffer))
        (setf x (elt input-buffer i))
        (setf y (elt pad-buffer (+ i offset)))
        (setf cur (modo - x y *max-int*))
        (setf output-buffer (append output-buffer (list cur))))
      (princ (%octets-to-string (coerce output-buffer 'vector) *encoding*)))))

(defun main (args)
  (let (
    (op (first args))
    (input (second args))
    (pad (third args))
    (offset (fourth args)))
    (when (null op)
      (error "must supply operation"))
    (block nil
      (when (string= op "gen")
        (return (gen input)))
      (when (string= op "enc")
        (return (enc input pad offset)))
      (when (string= op "dec")
        (return (dec input pad offset)))
      (error (concatenate 'string "unknown operation " op))
    )))

(main *args*)
