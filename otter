#! /usr/local/bin/clisp
(setf *encoding* :utf-8)
(setf *random-state* (make-random-state t))
(setf *max-int* 128)

(defun file (filename)
  )

(defun byte-divisible (n)
  (if (zerop (mod size 8)) t nil))

(defun mod+ (a b c)
  (mod (+ (mod a c) (mod b c)) c))

(defun mod- (a b c)
  (mod (- (mod a c) (mod b c)) c))

(progn
  (defun encoding-keyword-to-native (encoding)
    (intern (string encoding) (find-package :charset)))
  (defun %string-to-octets (string encoding)
    (ext:convert-string-to-bytes string (encoding-keyword-to-native encoding)))
  (defun %octets-to-string (octets encoding)
    (ext:convert-string-from-bytes octets (encoding-keyword-to-native encoding))))

(defun rand (size)
  (let ((lst ()))
    (dotimes (i size)
       (setf lst (cons (random 128) lst)))
   lst))

; TODO prints extra byte?
(defun gen (size-string)
  (when (null input)
    (error "must supply pad size"))
  (setf size (parse-integer size-string :junk-allowed t))
  (unless (numberp size)
    (error "size must be a number"))
  (unless (byte-divisible size)
    (error "size must dbe divisible by 8"))
  (defvar buffer (rand size))
  (princ (%octets-to-string (coerce buffer 'vector) *encoding*)))

(defun enc (input-path pad-path offset-string)
  (when (null input-path)
    (error "must supply input path"))
  (when (null pad-path)
    (error "must supply pad path"))
  (when (null offset-string)
    (setq offset-string "0"))
  (setq offset (parse-integer offset-string :junk-allowed t))
  (unless (numberp offset)
    (error "offset must be a number"))
  (with-open-file (input input-path)
    (with-open-file (pad pad-path)
      (setq input-buffer (%string-to-octets (read-line input) *encoding*))
      (setq pad-buffer (%string-to-octets (read-line pad) *encoding*))
      (setq output-buffer '())
      (when (> (+ offset (length input-buffer)) (length pad-buffer))
        (error "offset is too large for pad"))
      (dotimes (i (length input-buffer))
        (setf x (elt input-buffer i))
        (setf y (elt pad-buffer (+ i offset)))
        (setf cur (mod+ x y *max-int*))
        (setf output-buffer (append output-buffer (list cur))))
      (princ (%octets-to-string (coerce output-buffer 'vector) *encoding*)))))

(defun dec (input-path pad-path offset-string)
  (when (null input-path)
    (error "must supply input path"))
  (when (null pad-path)
    (error "must supply pad path"))
  (when (null offset-string)
    (setq offset-string "0"))
  (setq offset (parse-integer offset-string :junk-allowed t))
  (unless (numberp offset)
    (error "offset must be a number"))
  (with-open-file (input input-path)
    (with-open-file (pad pad-path)
      (setq input-buffer (%string-to-octets (read-line input) *encoding*))
      (setq pad-buffer (%string-to-octets (read-line pad) *encoding*))
      (setq output-buffer '())
      (when (> (+ offset (length input-buffer)) (length pad-buffer))
        (error "offset is too large for pad"))
      (dotimes (i (length input-buffer))
        (setf x (elt input-buffer i))
        (setf y (elt pad-buffer (+ i offset)))
        (setf cur (mod- x y *max-int*))
        (setf output-buffer (append output-buffer (list cur))))
      (princ (%octets-to-string (coerce output-buffer 'vector) *encoding*)))))

(defun main (args)
  (setq op (first args))
  (setq input (second args))
  (setq pad (third args))
  (setq offset (fourth args))
  (when (null op)
    (error "must supply operation"))
  (block nil
    (when (string= op "gen")
      (return (gen input)))
    (when (string= op "enc")
      (return (enc input pad offset)))
    (when (string= op "dec")
      (return (dec input pad offset)))
    (error (concatenate 'string "unknown operation " op))
  )
)

(main *args*)
